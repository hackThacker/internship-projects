# scanner/sqli_scanner_async.py - NEW HIGH-PERFORMANCE SCANNER

import asyncio
import aiohttp
import re
from urllib.parse import urlencode, parse_qs, urlsplit, urlunsplit
from .payloads import SQLI_PAYLOADS, SQLI_ERROR_PATTERNS
from .cvss import get_cvss_score
import time

class AsyncSQLiScanner:
    def __init__(self, urls, log_queue, concurrency=50, timeout=15):
        self.urls_to_scan = urls
        self.log_queue = log_queue # Thread-safe queue for logging
        self.payloads = SQLI_PAYLOADS["Error-Based"]
        self.concurrency = concurrency
        self.timeout = timeout
        self.vulnerabilities = []
        self.total_requests = 0

    def log(self, message, css_class=""):
        self.log_queue.put(f'<span class="{css_class}">{message}</span>')

    def generate_payload_urls(self, url):
        """Generates URLs with SQLi payloads injected into each parameter."""
        url_combinations = []
        try:
            scheme, netloc, path, query_string, fragment = urlsplit(url)
            query_params = parse_qs(query_string, keep_blank_values=True)
            if not query_params: return []

            for key, values in query_params.items():
                original_value = values[0]
                for payload in self.payloads:
                    modified_params = query_params.copy()
                    modified_params[key] = [original_value + payload]
                    modified_query = urlencode(modified_params, doseq=True)
                    modified_url = urlunsplit((scheme, netloc, path, modified_query, fragment))
                    url_combinations.append((modified_url, payload)) # Store payload with URL
            self.total_requests += len(url_combinations)
            return url_combinations
        except ValueError:
            return []

    async def fetch(self, sem: asyncio.Semaphore, session: aiohttp.ClientSession, url: str, payload: str):
        """Performs a single async GET request and checks for SQL error patterns."""
        async with sem:
            try:
                async with session.get(url, allow_redirects=True) as resp:
                    content = await resp.text()
                    for pattern in SQLI_ERROR_PATTERNS:
                        if re.search(pattern, content, re.IGNORECASE):
                            return (url, payload, pattern)
            except (aiohttp.ClientError, asyncio.TimeoutError):
                pass
            return None

    async def scan_all(self):
        sem = asyncio.Semaphore(self.concurrency)
        timeout_config = aiohttp.ClientTimeout(total=self.timeout)
        tasks = []

        urls_with_params = [url for url in self.urls_to_scan if '?' in url]

        async with aiohttp.ClientSession(timeout=timeout_config, connector=aiohttp.TCPConnector(ssl=False, limit=0, enable_cleanup_closed=True)) as session:
            for url in urls_with_params:
                urls_to_test = self.generate_payload_urls(url)
                for test_url, payload in urls_to_test:
                    task = asyncio.ensure_future(self.fetch(sem, session, test_url, payload))
                    tasks.append(task)
            
            self.log(f"[*] SQLi Scan: Launching {len(tasks)} concurrent requests...", "log-scan")
            
            for future in asyncio.as_completed(tasks):
                result = await future
                if result:
                    result_url, payload, pattern = result
                    vuln = self.create_vulnerability_entry(result_url, payload, pattern)
                    self.vulnerabilities.append(vuln)
                    self.log(f"[+] SQLi Vulnerability Found: {result_url}", "log-vuln-critical")

    def create_vulnerability_entry(self, url, payload, pattern):
        vuln_type = "Error-Based SQL Injection"
        cvss_info = get_cvss_score(vuln_type)
        return {
            "type": vuln_type, "location": url, "payload": payload,
            "evidence": f"Response contained a known SQL error pattern: '{pattern}'",
            "severity": cvss_info["severity"], "cvss_score": cvss_info["score"],
            "cvss_vector": cvss_info["vector"]
        }

    def run(self):
        """Entry point to run the asyncio event loop."""
        self.log(f"[*] Starting Advanced SQLi Scan ({self.concurrency} concurrency)...", "log-phase")
        try:
            asyncio.run(self.scan_all())
        except Exception as e:
            self.log(f"An error occurred during async SQLi scan: {e}", "log-error")