# scanner/xss_scanner_async.py - NEW HIGH-PERFORMANCE SCANNER

import asyncio
import aiohttp
from urllib.parse import urlencode, parse_qs, urlsplit, urlunsplit, quote
from .payloads import XSS_POLYGLOT_PAYLOAD
from .cvss import get_cvss_score
import time

class AsyncXSSScanner:
    def __init__(self, urls, log_queue, concurrency=50, timeout=15):
        self.urls_to_scan = urls
        self.log_queue = log_queue  # Thread-safe queue for logging
        self.payload = XSS_POLYGLOT_PAYLOAD
        self.encoded_payload = quote(self.payload)
        self.concurrency = concurrency
        self.timeout = timeout
        self.vulnerabilities = []
        self.total_requests = 0

    def log(self, message, css_class=""):
        """Puts a log message into the queue for the Flask app to stream."""
        self.log_queue.put(f'<span class="{css_class}">{message}</span>')

    def generate_payload_urls(self, url):
        """Generates URLs with the payload injected into each parameter."""
        url_combinations = []
        try:
            scheme, netloc, path, query_string, fragment = urlsplit(url)
            query_params = parse_qs(query_string, keep_blank_values=True)
            if not query_params:
                return []
            
            for key in query_params.keys():
                modified_params = query_params.copy()
                modified_params[key] = [self.payload]
                modified_query = urlencode(modified_params, doseq=True)
                modified_url = urlunsplit((scheme, netloc, path, modified_query, fragment))
                url_combinations.append(modified_url)
            self.total_requests += len(url_combinations)
            return url_combinations
        except ValueError:
            return []

    async def fetch(self, sem: asyncio.Semaphore, session: aiohttp.ClientSession, url: str):
        """Performs a single async GET request."""
        async with sem:
            try:
                async with session.get(url, allow_redirects=True) as resp:
                    if "text/html" in resp.headers.get("Content-Type", ""):
                        content = await resp.text()
                        if self.payload in content:
                            return url
            except (aiohttp.ClientError, asyncio.TimeoutError):
                pass
            return None

    async def scan_all(self):
        """The main async scanning function."""
        sem = asyncio.Semaphore(self.concurrency)
        timeout_config = aiohttp.ClientTimeout(total=self.timeout)
        tasks = []
        
        urls_with_params = [url for url in self.urls_to_scan if '?' in url]

        async with aiohttp.ClientSession(timeout=timeout_config, connector=aiohttp.TCPConnector(ssl=False, limit=0, enable_cleanup_closed=True)) as session:
            for url in urls_with_params:
                urls_to_test = self.generate_payload_urls(url)
                for test_url in urls_to_test:
                    task = asyncio.ensure_future(self.fetch(sem, session, test_url))
                    tasks.append(task)
            
            self.log(f"[*] XSS Scan: Launching {len(tasks)} concurrent requests...", "log-scan")
            
            # Run tasks and process results as they complete
            for future in asyncio.as_completed(tasks):
                result_url = await future
                if result_url:
                    vuln = self.create_vulnerability_entry(result_url)
                    self.vulnerabilities.append(vuln)
                    self.log(f"[+] XSS Vulnerability Found: {result_url}", "log-vuln-high")
    
    def create_vulnerability_entry(self, url):
        """Creates a formatted dictionary for a found vulnerability."""
        vuln_type = "Reflected Cross-Site Scripting (XSS)"
        cvss_info = get_cvss_score(vuln_type)
        return {
            "type": vuln_type, "location": url, "payload": self.payload,
            "evidence": "Polyglot payload was reflected in the HTTP response.",
            "severity": cvss_info["severity"], "cvss_score": cvss_info["score"],
            "cvss_vector": cvss_info["vector"]
        }
    
    def run(self):
        """Entry point to run the asyncio event loop."""
        self.log(f"[*] Starting Advanced XSS Scan ({self.concurrency} concurrency)...", "log-phase")
        try:
            asyncio.run(self.scan_all())
        except Exception as e:
            self.log(f"An error occurred during async XSS scan: {e}", "log-error")